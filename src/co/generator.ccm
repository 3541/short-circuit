/*
 * FUTURE -- A generic repeatable coroutine type.
 *
 * Copyright (c) 2023, Alex O'Brien <3541@3541.website>
 *
 * This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of
 * the MPL was not distributed with this file, you can obtain one at http://mozilla.org/MPL/2.0/.
 */

module;

#include <cassert>
#include <climits>
#include <coroutine>
#include <utility>

#include <a3/util.hh>

import sc.co.resume;
import sc.lib.deque;

export module sc.co.generator;

namespace sc::co {

export template <typename T>
struct Generator {
    A3_NO_COPY(Generator);

private:
    struct Promise;

    std::coroutine_handle<Promise> m_handle;

public:
    using promise_type = Promise;

    explicit Generator(std::coroutine_handle<Promise>);

    ~Generator();

    bool await_ready() const noexcept;
    void await_suspend(std::coroutine_handle<>) noexcept;
    T    await_resume() noexcept;
};

template <typename T>
struct Generator<T>::Promise {
private:
    lib::Deque<T>           m_yielded;
    std::coroutine_handle<> m_caller;

public:
    friend struct Generator<T>;

    std::suspend_never  initial_suspend() const noexcept;
    std::suspend_always final_suspend() const noexcept;

    Generator<T> get_return_object() noexcept;

    void unhandled_exception() noexcept;

    void   return_void() noexcept;
    Resume yield_value(T) noexcept;
};

template <typename T>
std::suspend_never Generator<T>::Promise::initial_suspend() const noexcept {
    return {};
}

template <typename T>
std::suspend_always Generator<T>::Promise::final_suspend() const noexcept {
    return {};
}

template <typename T>
Generator<T> Generator<T>::Promise::get_return_object() noexcept {
    return Generator{std::coroutine_handle<Promise>::from_promise(*this)};
}

template <typename T>
Resume Generator<T>::Promise::yield_value(T value) noexcept {
    assert(m_caller);

    m_yielded.push_back(std::move(value));
    return Resume{m_caller};
}

template <typename T>
Generator<T>::Generator(std::coroutine_handle<Promise> handle) : m_handle{handle} {}

template <typename T>
Generator<T>::~Generator() {
    if (m_handle)
        m_handle.destroy();
}

template <typename T>
bool Generator<T>::await_ready() const noexcept {
    return !m_handle.promise().m_yielded.is_empty();
}

template <typename T>
void Generator<T>::await_suspend(std::coroutine_handle<> handle) noexcept {
    m_handle.promise().m_caller = handle;
}

template <typename T>
T Generator<T>::await_resume() noexcept {
    auto& pending = m_handle.promise().m_yielded;
    assert(!pending.is_empty());

    return *pending.pop_front();
}

} // namespace sc::co
