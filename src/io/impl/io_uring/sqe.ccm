/*
 * SQE -- An awaitable io_uring submission.
 *
 * Copyright (c) 2023, Alex O'Brien <3541@3541.website>
 *
 * This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of
 * the MPL was not distributed with this file, you can obtain one at http://mozilla.org/MPL/2.0/.
 */

module;

#include <cassert>
#include <climits>
#include <coroutine>
#include <cstdint>
#include <exception>
#include <expected>
#include <functional>
#include <optional>
#include <type_traits>
#include <utility>
#include <variant>

#include <liburing.h>

#include "sc/lib/fwd.hh"

export module sc.io.impl.uring.sqe;

import sc.io.buf;
import sc.io.error;
import sc.lib.deque;

namespace sc::io::impl::uring {

export struct Cqe {
protected:
    ~Cqe() = default;

public:
    using RequestFailed = RequestFailed;

    virtual void complete(io_uring_cqe const&) noexcept = 0;
};

struct Result {
    std::int32_t           m_res;
    std::optional<Buf::Id> m_buf;

    explicit Result(io_uring_cqe const&) noexcept;
    Result(std::int32_t, std::optional<Buf::Id>) noexcept;

    constexpr bool operator==(Result const&) const noexcept = default;

    std::expected<std::uint32_t, Cqe::RequestFailed> result() const noexcept;
};

struct SingleCqe final : public Cqe {
private:
    std::coroutine_handle<> m_handle;
    std::optional<Result>   m_result;

    template <typename C>
        requires std::is_nothrow_invocable_r_v<io_uring_sqe*, C>
    friend struct Sqe;

    explicit SingleCqe(io_uring_sqe&) noexcept;

public:
    ~SingleCqe();

    void complete(io_uring_cqe const&) noexcept final;

    bool   await_ready() const noexcept;
    void   await_suspend(std::coroutine_handle<>) noexcept;
    Result await_resume() noexcept;
};

export {
    template <typename C>
        requires std::is_nothrow_invocable_r_v<io_uring_sqe*, C>
    struct Sqe {
    private:
        C m_sqe;

    public:
        template <typename T>
            requires std::is_nothrow_invocable_r_v<io_uring_sqe*, T>
        constexpr explicit Sqe(T&& sqe) : m_sqe{SC_FWD(sqe)} {}

        auto operator co_await() && {
            auto* sqe = std::invoke(std::move(m_sqe));
            if (!sqe) {
                // TODO
                std::terminate();
            }

            return SingleCqe{*sqe};
        }
    };

    template <typename C>
    Sqe(C) -> Sqe<C>;

    template <typename C>
        requires std::is_nothrow_invocable_r_v<io_uring_sqe*, C>
    struct MultishotSqe final : public Cqe {
    public:
        enum class State : bool { Alive, Resubmit };

    private:
        std::variant<std::monostate, C, std::coroutine_handle<>> m_state;
        State                                                    m_request_state{State::Alive};
        lib::Deque<Result>                                       m_results;

    public:
        constexpr explicit MultishotSqe(C sqe) : m_state{std::move(sqe)} {}

        ~MultishotSqe() {
            if (auto* handle = std::get_if<std::coroutine_handle<>>(&m_state))
                handle->destroy();
        }

        bool await_ready() const noexcept {
            return !m_results.is_empty() || m_request_state == State::Resubmit;
        }

        void await_suspend(std::coroutine_handle<> handle) noexcept {
            assert(!std::holds_alternative<std::coroutine_handle<>>(m_state));

            if (std::holds_alternative<C>(m_state)) {
                auto* sqe = std::invoke(std::get<C>(std::exchange(m_state, std::monostate{})));
                if (!sqe) {
                    // TODO
                    std::terminate();
                }

                ::io_uring_sqe_set_data(sqe, this);
            }

            m_state = handle;
        }

        std::optional<Result> await_resume() noexcept { return m_results.pop_front(); }

        void complete(io_uring_cqe const& cqe) noexcept final {
            m_results.emplace_back(cqe);
            if (!(cqe.flags & IORING_CQE_F_MORE))
                m_request_state = State::Resubmit;

            if (std::holds_alternative<std::coroutine_handle<>>(m_state))
                std::get<std::coroutine_handle<>>(std::exchange(m_state, std::monostate{}))();
        }

        bool done() const noexcept {
            return m_request_state == State::Resubmit && m_results.is_empty();
        }
    };
}

} // namespace sc::io::impl::uring
